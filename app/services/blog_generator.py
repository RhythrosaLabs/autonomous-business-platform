"""
blog_generator.py (Replicate-powered)

Generates a rich blog post about a product using Replicate GPT-OSS for text and Flux Fast for images.
- Outputs: HTML file (and PDF/text fallback)
- Inserts 3 illustrative images generated by Replicate, based on product/topic sections
- If a product image is provided, it's used as the hero image at the top
"""

import os
import re
import json
import requests
from datetime import datetime

try:
    from weasyprint import HTML  # requires system libs (pango, gobject)
    _WEASYPRINT_AVAILABLE = True
except Exception:
    _WEASYPRINT_AVAILABLE = False

from app.services.api_service import ReplicateAPI


def _strip_code_fences(text: str) -> str:
    if text is None:
        return ""
    return re.sub(r"^```[a-zA-Z]*\n|\n```$", "", text.strip())


def generate_blog_content(product_name: str, product_description: str, tone: str = "Professional", replicate_token: str | None = None) -> dict:
    """Use Replicate GPT-OSS to produce a structured JSON for the blog.

    Returns a dict with keys: title, sections (list of {heading, html}), image_captions (list of 3 strings)
    """
    client = ReplicateAPI(replicate_token or os.getenv("REPLICATE_API_TOKEN", ""))
    sys_prompt = (
        "You are an expert ecommerce blog writer. Produce structured JSON for a product blog."
    )
    user_prompt = f"""
Create a compelling, SEO-friendly blog for the product below.

Product Name: {product_name}
Description: {product_description}
Tone: {tone}

Output STRICT JSON with this schema:
{{
  "title": "<engaging title>",
  "sections": [
    {{"heading": "Introduction", "html": "<p>...</p>"}},
    {{"heading": "Section 1", "html": "<p>...</p>"}},
    {{"heading": "Section 2", "html": "<p>...</p>"}},
    {{"heading": "Conclusion", "html": "<p>...</p>"}}
  ],
  "image_captions": [
    "<short visual description for image 1>",
    "<short visual description for image 2>",
    "<short visual description for image 3>"
  ]
}}

Constraints:
- Use HTML tags INSIDE each section's html value. No markdown.
- Avoid cheesy claims; be specific and product-focused.
- Keep it 800-1200 words overall.
"""
    raw = client.generate_text(user_prompt, max_tokens=1500, temperature=0.7, system_prompt=sys_prompt)
    text = _strip_code_fences(raw)
    try:
        data = json.loads(text)
    except Exception:
        # best-effort: try to extract JSON
        m = re.search(r"\{[\s\S]*\}$", text)
        data = json.loads(m.group(0)) if m else {"title": f"{product_name} - Product Blog", "sections": [], "image_captions": []}
    # Validate minimal structure
    data.setdefault("title", f"{product_name} - Product Blog")
    data.setdefault("sections", [])
    data.setdefault("image_captions", [])
    return data


def generate_images_for_blog(captions: list[str], out_dir: str, replicate_token: str | None = None) -> list[str]:
    """Generate three images using Replicate Flux Fast based on provided captions.
    
    Returns list of Replicate-hosted URLs (no local download needed).
    """
    os.makedirs(out_dir, exist_ok=True)
    client = ReplicateAPI(replicate_token or os.getenv("REPLICATE_API_TOKEN", ""))
    urls = []
    for i, cap in enumerate((captions or [])[:3], start=1):
        prompt = f"High-quality, modern blog illustration about: {cap}. Clean, commercial-ready, no text overlays."
        try:
            url = client.generate_image(prompt, width=1280, height=720, aspect_ratio="16:9", output_format="png")
            if url:
                # Keep the Replicate CDN URL directly - no download needed!
                urls.append(url)
                
                # Also save locally for backup/reference
                try:
                    resp = requests.get(url, timeout=60)
                    resp.raise_for_status()
                    p = os.path.join(out_dir, f"blog_image_{i}.png")
                    with open(p, "wb") as f:
                        f.write(resp.content)
                except Exception:
                    pass  # Local save is optional
        except Exception:
            continue
    return urls


def insert_images_smart(html_content: str, image_paths: list[str]) -> str:
    """Insert <img> tags at logical points (after intro, mid, before conclusion)."""
    if not image_paths:
        return html_content
    # split by </h2> boundaries if present
    parts = re.split(r"(</h2>)", html_content, maxsplit=0)
    img_tag_tpl = '<img src="{src}" alt="Blog illustration" style="width:100%;max-width:720px;height:auto;border-radius:12px;margin:1.5rem 0;box-shadow:0 4px 20px rgba(0,0,0,0.1);">'
    def ins(where_idx: int, src_idx: int):
        if src_idx >= len(image_paths):
            return
        tag = img_tag_tpl.format(src=image_paths[src_idx])
        if len(parts) >= where_idx + 1:
            parts[where_idx] = parts[where_idx] + tag
    # After first </h2>
    if len(parts) >= 2:
        ins(1, 0)
    # Midway
    if len(parts) >= 4:
        ins(3, 1)
    # Before conclusion: append to end
    if len(parts) >= 1 and len(image_paths) >= 3:
        parts[-1] = parts[-1] + img_tag_tpl.format(src=image_paths[2])
    return "".join(parts)


def export_blog_as_html(title, html_content, output_path):
    html_template = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{title}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body{{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans';line-height:1.6;margin:2rem;color:#111827}}
        h1{{font-size:2rem;margin-bottom:1rem}}
        h2{{border-bottom:2px solid #4f46e5;padding-bottom:.3rem;margin-top:2rem}}
        img{{max-width:100%;border-radius:12px;margin:1rem 0;box-shadow:0 4px 20px rgba(0,0,0,.1)}}
        article{{max-width:860px;margin:auto}}
    </style>
</head>
<body>
<article>
<h1>{title}</h1>
{html_content}
</article>
</body>
</html>
"""
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(html_template)
    return output_path


def export_blog_as_pdf(html_path, pdf_path):
    if not _WEASYPRINT_AVAILABLE:
        with open(html_path, 'r', encoding='utf-8') as f_in, open(pdf_path.replace('.pdf', '_fallback.txt'), 'w', encoding='utf-8') as f_out:
            f_out.write("PDF generation unavailable (missing system deps). Content below:\n\n")
            f_out.write(f_in.read())
        return pdf_path.replace('.pdf', '_fallback.txt')
    from weasyprint import HTML as _HTML
    _HTML(html_path).write_pdf(pdf_path)
    return pdf_path


def generate_product_blog(product_name: str, product_description: str, tone: str = "Professional", output_dir: str = "blogs", image_path: str | None = None):
    os.makedirs(output_dir, exist_ok=True)

    data = generate_blog_content(product_name, product_description, tone)
    # Compose HTML from sections
    sections_html = []
    for sec in data.get("sections", []):
        heading = sec.get("heading", "").strip()
        html = sec.get("html", "").strip()
        if heading:
            sections_html.append(f"<h2>{heading}</h2>\n{html}")
        else:
            sections_html.append(html)
    html_content = "\n".join(sections_html)

    # Generate 3 images with Replicate
    imgs_dir = os.path.join(output_dir, "images")
    os.makedirs(imgs_dir, exist_ok=True)
    img_paths = generate_images_for_blog(data.get("image_captions", []), imgs_dir)

    # Insert hero image if provided
    if image_path and os.path.exists(image_path):
        hero_tag = f'<img src="{image_path}" alt="Product" style="width:100%;max-width:860px;height:auto;border-radius:12px;margin:1.5rem 0;box-shadow:0 4px 20px rgba(0,0,0,0.1);">'
        html_content = hero_tag + html_content

    html_with_images = insert_images_smart(html_content, img_paths)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe = re.sub(r"[^A-Za-z0-9_-]+", "_", product_name.strip().replace(" ", "_")).lower() or "product"
    html_path = os.path.join(output_dir, f"{safe}_{timestamp}.html")
    pdf_path = os.path.join(output_dir, f"{safe}_{timestamp}.pdf")
    export_blog_as_html(data.get("title", product_name), html_with_images, html_path)
    pdf_result = export_blog_as_pdf(html_path, pdf_path)
    return html_path, pdf_result


if __name__ == "__main__":
    product = "Printify Pro"
    description = "A next-generation print-on-demand platform for creators and businesses."
    html_file, pdf_file = generate_product_blog(product, description)
    print(f"Blog generated: {html_file}, {pdf_file}")
